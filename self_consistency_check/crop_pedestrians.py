import cv2
import pandas as pd
import tqdm
import os


def object_cropper(args):
    gt_df = pd.read_csv(args.csv_outputs + "cityscapes_generated_gtbboxes.csv")
    generated_image_directory = (args.generated_image_folder_path)

    for row in tqdm.tqdm(gt_df.iterrows()):
        x1 = row[1]["x1_list"]
        y1 = row[1]["y1_list"]
        x2 = row[1]["x2_list"]
        y2 = row[1]["y2_list"]
        w = x2 - x1
        h = y2 - y1
        s = y2 - y1  # side of square we want to obtain
        x_center = x1 + w
        x_min_new = int(x_center - s / 2)
        y_min_new = int(y1)
        x_max_new = int(x_center + s / 2)
        y_max_new = int(y2)
        if (
            int(x_min_new) > 0
            and int(x_max_new) < 1920
            and int(y_min_new) > 0
            and int(y_max_new) < 1024
        ):
            substring = "00000-" + row[1]["Filename"]
            matched_file = [
                f for f in os.listdir(generated_image_directory) if substring in f
            ]
            img = cv2.imread(
                generated_image_directory + matched_file[0]
            )

            img_cropped = img[y_min_new:y_max_new, x_min_new:x_max_new]
            filename = row[1]["Filename"]
            try:
                cv2.imwrite(args.image_crop_path + f"/{filename}" + ".png", img_cropped)
            except cv2.error as e:
                print("Crop file did not get written", e)