from __future__ import annotations

import argparse
import os
import sys
import numpy as np
from PIL import Image
import torch
import tqdm
import random
import glob

# initialization from webui
from modules import timer
from modules import initialize


#codeformer_model.setup_model(dirname="CodeFormer")
from modules.processing import StableDiffusionProcessingImg2Img, process_images
from modules.sd_models import CheckpointInfo, load_model, read_state_dict
from modules import shared
from modules.lang_sam.lang_sam import LangSAM

# load webui extension libraries
from scripts.controlnet import Script as ControlScript
from internal_controlnet.external_code import ControlNetUnit
from modules.processing_scripts import refiner, seed


def scale_image(image, new_width, new_height):
    try:
        rescaled = image.resize((new_width, new_height), Image.Resampling.LANCZOS)
        return rescaled
    except IOError:
        print("Cannot resize the image for '%s'" % image)
        raise IOError
  
        
def get_mask_and_pose(args, image, pose_array):
    # numpy uses different orientation, so change x,y to y,x 
    mask_width, mask_height = random.choice([[75, 150], [50, 100], [120, 240]])
    print(mask_width)
    print(mask_height)
    skip_flag = False
    # rescale pose image
    pose_image = Image.fromarray(pose_array)
    pose_image = scale_image(pose_image, new_width=mask_width, new_height=mask_height)  ## frederic flipped this. i chnaged it abck
    pose = np.array(pose_image)
    print(f"Pose shape is {pose.shape}")
    
    # load model to detect space
    model = LangSAM(sam_type="vit_b")
    image = image.convert("RGB")
    text_prompt = "street"
    
    # detect free pixels
    masks, boxes, phrases, logits = model.predict(image, text_prompt)
    masks = masks.numpy()
    print(f"mask shape is {masks.shape}")
    if masks.size == 0:
        skip_flag = True
        return None, skip_flag, None, None, None, None, None
    else:
        masks = masks[0,:,:] ## shape of image 512, 768
        
        # masks contains non-zero value for indices that belong to text_prompt
        # all other values are zero
        pixel_indices = np.where(masks) # tuple of x,y values
        print("Searching for a central mask position")
        print(pixel_indices)
        print(pixel_indices[0].size)
        print(pixel_indices[1].size)

        indices_x_min_limit = np.where(pixel_indices[1] - mask_width / 2 > 0)[0]
        indices_x_max_limit = np.where(pixel_indices[1] + mask_width / 2 < masks.shape[1])[0]
        indices_y_min_limit = np.where(pixel_indices[0] - mask_height / 2 > 0)[0]
        indices_y_max_limit = np.where(pixel_indices[0] + mask_height / 2 < masks.shape[0])[0]
        indices = np.where(pixel_indices[0] < masks.shape[0] / 2)[0] # single dimensional 
        
        combined_indices = np.intersect1d(indices_x_min_limit, indices_x_max_limit)
        combined_indices = np.intersect1d(combined_indices, indices_y_min_limit)
        combined_indices = np.intersect1d(combined_indices, indices_y_max_limit)
        combined_indices = np.intersect1d(combined_indices, indices)
        print(combined_indices)
        
        # Filter the x and y positions using these indices
        filtered_y_positions = pixel_indices[0][combined_indices]
        filtered_x_positions = pixel_indices[1][combined_indices]
       
        print(filtered_x_positions, filtered_y_positions)
        if len(combined_indices) == 0:
            skip_flag = True

            return None, skip_flag, None, None, None, None, None
        else:
            ii = np.random.choice(combined_indices, replace=False)
            random_x, random_y = pixel_indices[1][ii], pixel_indices[0][ii]
            print(random_x, random_y)
            # create mask and shift pose
            final_mask = np.zeros_like(masks)
            print(f"final mask shape {final_mask.shape}")

            final_pose = np.zeros(shape=(final_mask.shape[0], final_mask.shape[1], 3),dtype='uint8')
            print(f"final pose shape {final_pose.shape}")

            #use the free pixel as the center of the width of the mask
            x_limit = (random_x - mask_width/2 >= 0 ) and (random_x + mask_width/2 < final_mask.shape[1])
            y_limit = (random_y - mask_height/2 >= 0 ) and (random_y + mask_height/2 < final_mask.shape[0])

            if x_limit and y_limit :
                xi = int(random_x - mask_width/2)
                yi = int(random_y - mask_height/2)
                try:
                    final_mask[yi:yi+mask_height, xi:xi+mask_width] = 255
                    final_pose[yi:yi+mask_height, xi:xi+mask_width, :] = pose[:,:,:3]
                    xi2 = xi+mask_width
                    yi2 = yi+mask_height        
                except IndexError:
                    print("Mask generation wrong. Try to decrease the size of the mask, or upload an existing mask and pose.")
            print(f"final mask shape before output {final_mask.shape}")
            print(f"final mask shape before output {final_pose.shape}")
            print(f"{xi,yi,xi2,yi2}")
            return Image.fromarray(final_mask).convert(mode="L"), skip_flag, final_pose, xi, yi, xi2, yi2


def get_images(args):
    image_paths = []
    if args.input_image_path.endswith(".png"):
        print("Single image input")
        image_paths.append(args.input_image_path)
    else:
        folder_list = os.listdir(args.input_image_path)
        folder_list = sorted(folder_list)
        for fl in folder_list:
            if fl.endswith(".png"):
                image_paths.append(os.path.join(args.input_image_path, fl))    
        print(f"Folder of {len(image_paths)} images")
    return image_paths


def define_mask(args, init_images, pose_array, file_path):    
    print("Generating new mask and shifting the pose.")
    mask, skip_flag, pose_array, xi, yi, xi2, yi2 = get_mask_and_pose(args, init_images[0], pose_array)
    print(file_path)
    filename = file_path.split("/")[-1].split(".")[0]
    with open(args.output_mask_positions+ f"{filename}.txt", "w") as mask_position_file:
        mask_position_file.write(str(xi))
        mask_position_file.write(", ")
        mask_position_file.write(str(yi))
        mask_position_file.write("\n")
        mask_position_file.write(str(xi2))
        mask_position_file.write(", ")
        mask_position_file.write(str(yi2))
    if skip_flag:
        pose_image = None
    else:
        pose_image = Image.fromarray(pose_array)
    return mask, pose_image, skip_flag

def get_controlnet_pose_image(args, prompts):
    if args.pose_path is None:
            pose_array = np.zeros(shape=(10, 10))
    else:
        pose_array = None
        print(prompts.split(" ")[9])

        prefix = 'walk_' if prompts.split(" ")[9] == 'walking,' else 'run_'

        # Get a list of all files in the folder that match the prefix
        file_pattern = os.path.join(args.pose_path, f"{prefix}*")
        matching_files = glob.glob(file_pattern)
        pose_fl = random.choice(matching_files)
        print(pose_fl)
        with Image.open(pose_fl) as pose:    
            pose_array = np.array(pose)
    return pose_array


class PromptExpander:

    repl_list = {}
    _result = []

    def __init__(self, replacements = {}):
        self.repl_list = replacements
        return

    def register(self, token : str, repls: list):
        self.repl_list[token] = repls

    def expand(self, inp : str):
        self._result = []
        self._expand(inp)
        return self._result

    def _expand(self, inp : str):
        pieces = inp.split("[[", maxsplit=1)
        if len(pieces) == 1:
            self._result.append(inp)
            return inp
        head = pieces[0]
        pieces = pieces[1].split("]]", maxsplit=1)
        token = pieces[0]
        tail = pieces[1]
        res = [
            self._expand("".join([head, repl, tail]))
            for repl in self.repl_list[token]
        ]
        return res


def get_prompt():
    ## https://github.com/thombashi/allpairspy
    age = ['old', 'young']
    gender = ['male', 'female']
    skincolor = ['dark-skinned', 'white-skinned']
    shirtcolor = ['red', 'blue', 'green', 'black', 'white', 'brown', 'grey']
    action = ['walking', 'running']

    # approach 1
    pe = PromptExpander()
    pe.register('age', age)
    pe.register('gender', gender)
    pe.register('skincolor', skincolor)
    pe.register('shirtcolor', shirtcolor)
    pe.register('action', action)
    prompts = pe.expand("a [[age]] [[gender]] [[skincolor]] person:1.5 wearing [[shirtcolor]] colored shirt [[action]], full body shot") 
    prompt = random.choice(prompts)    
    return prompt